def propagate_iterative(self,
                            W,
                            xi,
                            b,
                            a=0.5,
                            lim_iter=1000,
                            tol=sys.float_info.epsilon,
                            get_trj=True):


        n = W.shape[0]
        # Initial values

        #x0 = np.zeros((n,), dtype=np.float)
        #x0[:] = xi
        x0 = np.array(xi, dtype=np.float64)

        x_t1 = x0.copy()

        if get_trj:
            # Record the initial states
            trj_x = []
            trj_x.append(x_t1.copy())

        # Main loop
        num_iter = 0
        for i in range(lim_iter):
            # Main formula
            x_t2 = a*W.dot(x_t1) + (1-a)*b
            num_iter += 1
            
            # Check termination condition
            if np.linalg.norm(x_t2 - x_t1) <= tol:
                break

            # Add the current state to the trajectory
            if get_trj:
                trj_x.append(x_t2)
            
            # Update the state
            x_t1 = x_t2.copy()
        # end of for
        
        if get_trj is False:
            return x_t2, num_iter
        else:
            g=np.array(trj_x)
            traj=g.tolist()
            np.savetxt("sfa_traj.txt",np.transpose(g),delimiter=" ")
            return x_t2, np.array(trj_x)
        

    # end of def propagate_iterative
# end of def class SignalPropagation
